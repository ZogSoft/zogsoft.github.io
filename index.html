<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ZogSoft</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      scroll-behavior: smooth;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }

    .hero-content {
      background: transparent;
      position: relative;
      z-index: 1;
      text-align: center;
      color: #fff;
      padding: 40vh 20px 50vh;
    }

    .hero-title {
      font-size: 5em;
      letter-spacing: 2px;
      font-weight: 900;
      text-shadow: 0 0 10px #2802cf, 0 0 20px #0073ff;
    }

    .hero-subtitle {
      font-size: 1.5em;
      color: #ccc;
      margin-top: 1em;
      text-shadow: 0 0 5px #000;
    }

    .scroll-down {
      margin-top: 3em;
      font-size: 1em;
      color: #00ffe1;
      cursor: pointer;
      text-decoration: underline;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }

    .section {
      background: #111;
      padding: 100px 20px;
      text-align: center;
      font-size: 1.5em;
      line-height: 1.8em;
    }
  </style>
</head>

<body>
  <canvas id="heroCanvas"></canvas>

  <div class="hero-content">
    <div class="hero-title">ZogSoft Games</div>
    <div class="hero-subtitle">Augmenting procedural generation with generative AI</div>
    <br>
    <a href="#more" class="scroll-down">▼ Scroll Down ▼</a>
  </div>

  <p align="center" font-style: italic><i>
    All tiles and monsters generated by our custom models.
  </i></p>


  <div id="more" class="section">
    <br>
    Welcome to ZogSoft! More information coming soon...
    <!-- <br><br>
    Subscribe here to stay updated. -->
  </div>

  <script>
    (function() {
      const canvas = document.getElementById('heroCanvas');
      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = false;

      // Set canvas dimensions to fill the window.
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      // Constants for sprite sizes and grid dimensions.
      const SPRITE_SIZE = 64;
      const SPRITESHEET_SIZE = 1152; // 576 x 576 spritesheet
      const GRID_COUNT = SPRITESHEET_SIZE / SPRITE_SIZE; // 18

      const TILE_SPRITESHEET_SIZE = 512;
      const TILE_GRID_COUNT = TILE_SPRITESHEET_SIZE / SPRITE_SIZE; // 18

      let MONSTER_DENSITY = 0.05;
      let BIOME_LENGTH = 25.0;

      const MOVE_TIME = 2000.0;
      const MOVE_SPD = 0.1;

      // Scrolling parameters.
      let scrollSpeed = 0.15; // pixels per .. second?
      let bgOffset = 0;
      let tilesPassed = 0;

      // Load spritesheets.
      const tileSheet = new Image();
      tileSheet.src = 'images/generated_tiles.png';
      const creatureSheet = new Image();
      creatureSheet.src = 'images/generated_creatures.png';

      // Array to hold monster objects.
      const monsters = [];
      // const spawnInterval = 2000; // new monster every 2 seconds
      // let lastSpawnTime = 0;

      // Function to spawn a new monster.
      function spawnMonster() {
        // Choose a random index between 0 and 323.
        const index = Math.floor(Math.random() * (GRID_COUNT * GRID_COUNT));
        const srcX = (index % GRID_COUNT) * SPRITE_SIZE;
        const srcY = Math.floor(index / GRID_COUNT) * SPRITE_SIZE;
        // Spawn the monster at a random vertical position along the right edge.
        monsters.push({
          x: Math.random() * (canvas.width - SPRITE_SIZE), // canvas.width
          y: Math.random() * (canvas.height - SPRITE_SIZE),
          srcX: srcX,
          srcY: srcY,
          t: Math.random() * MOVE_TIME,
          vx: Math.random() * 2 - 1,
          vy: Math.random() * 2 - 1
        });
      }

      let lastTimestamp = 0;

      let startBiome = Math.floor(Math.random() * TILE_GRID_COUNT * TILE_GRID_COUNT);

      // Main animation loop.
      function animate(timestamp) {
        let dt = (timestamp - lastTimestamp);
        lastTimestamp = timestamp;

        // Clear canvas.
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Update background offset.
        bgOffset = bgOffset + scrollSpeed * dt;
        if (bgOffset > SPRITE_SIZE){
            bgOffset = bgOffset % SPRITE_SIZE;
            tilesPassed++;
        }

        // Draw the background by repeating a single tile (top-left tile from tileSheet).
        let mx = Math.floor(canvas.width / SPRITE_SIZE) + 2;
        let xd = Math.floor(-1 * SPRITE_SIZE - bgOffset);
        for (let x = -1; x < mx; x += 1) {
          for (let y = 0; y < Math.floor(canvas.height / SPRITE_SIZE) + 1; y += 1) {
            let realx = x + tilesPassed;

            // Calculate biome index with jagged transition using hash noise
            let base = realx / BIOME_LENGTH;
            // Simple hash-like function for (realx, y) variation
            let variation = (((realx * 73856093) ^ (y * 19349663) + realx * realx * 7 + (realx * y) * 1283 + (realx | y) * 3517 ) & 0xffff) / 0xffff - 0.5;
            let biome = Math.floor(base + variation * 0.3); // 0.3 is the jaggedness strength

            biome += startBiome;

            // Clamp biome index if needed, e.g., 0 <= biome < totalBiomes
            biome = biome % (TILE_GRID_COUNT * TILE_GRID_COUNT);
            // biome = Math.max(0, Math.min(totalBiomes - 1, biome));

            // Example: use biome as tile index (idx, idy calculation depends on your tilesheet layout)
            let idx = (biome % TILE_GRID_COUNT);
            let idy = Math.floor(biome / TILE_GRID_COUNT);

            ctx.drawImage(
              tileSheet,
              idx * SPRITE_SIZE, idy * SPRITE_SIZE, SPRITE_SIZE, SPRITE_SIZE,       // Source: top-left tile.
              xd, y * SPRITE_SIZE, SPRITE_SIZE, SPRITE_SIZE  // Destination.
            );
          }
          xd += SPRITE_SIZE;
        }

        // Update and draw each monster.
        monsters.forEach(monster => {
          monster.x -= scrollSpeed * dt; // Move left.

          monster.t -= dt;
          if (monster.t < 0) {
            monster.t = (monster.t + MOVE_TIME) % MOVE_TIME;
            monster.vx = Math.random() * 2 - 1;
            monster.vy = Math.random() * 2 - 1;
          }
          if (monster.t < MOVE_TIME * 0.3) {
            monster.x += monster.vx * dt * MOVE_SPD;
            monster.y += monster.vy * dt * MOVE_SPD;
          }

          // Recycle monster when it goes off the left edge.
          if (monster.x < -SPRITE_SIZE) {

            monster.x = ((canvas.width + SPRITE_SIZE) + monster.x) % (canvas.width + SPRITE_SIZE);
            monster.y = Math.random() * (canvas.height - SPRITE_SIZE);

            const index = Math.floor(Math.random() * (GRID_COUNT * GRID_COUNT));
            monster.srcX = (index % GRID_COUNT) * SPRITE_SIZE;
            monster.srcY = Math.floor(index / GRID_COUNT) * SPRITE_SIZE;
        }
          ctx.drawImage(
            creatureSheet,
            monster.srcX, monster.srcY, SPRITE_SIZE, SPRITE_SIZE,  // Source: randomly chosen creature.
            monster.x, monster.y, SPRITE_SIZE, SPRITE_SIZE           // Destination.
          );
        });

        requestAnimationFrame(animate);
      }

      // Start the animation once both images have loaded.
      let loadedCount = 0;
      function checkLoaded() {
        loadedCount++;
        if (loadedCount === 2) {
          requestAnimationFrame(animate);
          let count = canvas.width * canvas.height * MONSTER_DENSITY / SPRITE_SIZE / SPRITE_SIZE;
            for (i=0; i<count; i++) spawnMonster();
        }
      }
      tileSheet.onload = checkLoaded;
      creatureSheet.onload = checkLoaded;
    })();
  </script>
</body>
</html>
